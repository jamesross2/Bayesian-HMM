import numpy
import typing
from . import utils as utils, variables as variables
from .chain import Chain as Chain, resample_latent_sequence as resample_latent_sequence
from .variables import hyperparameter as hyperparameter
from _typeshed import Incomplete

class HDPHMM:
    chains: Incomplete
    sticky: Incomplete
    alpha: Incomplete
    gamma: Incomplete
    kappa: Incomplete
    beta_emission: Incomplete
    transition_model: Incomplete
    emission_model: Incomplete
    emission_counts: Incomplete
    transition_counts: Incomplete
    emissions: Incomplete
    states: Incomplete
    def __init__(self, emission_sequences: typing.Iterable[typing.Sequence[variables.State]], emissions: typing.Optional[typing.Set[variables.State]] = ..., sticky: bool = ..., alpha: hyperparameter.Hyperparameter = ..., gamma: hyperparameter.Hyperparameter = ..., kappa: variables.Hyperparameter = ..., beta_emission: variables.Hyperparameter = ...) -> None: ...
    @property
    def initialised(self) -> bool: ...
    @initialised.setter
    def initialised(self, value: bool) -> None: ...
    @property
    def c(self) -> int: ...
    @property
    def k(self) -> int: ...
    @property
    def n(self) -> int: ...
    def to_array(self) -> numpy.array: ...
    def state_generator(self) -> typing.Generator[variables.State, None, None]: ...
    def initialise(self, k: int = ...) -> None: ...
    def update_states(self) -> None: ...
    def update_counts(self) -> None: ...
    def print_probabilities(self, digits: int = ...) -> typing.Tuple[str, str]: ...
    def chain_log_likelihoods(self) -> typing.List[float]: ...
    def log_likelihood(self) -> float: ...
    def resample_chains(self, ncores: int = ...): ...
    def maximise_hyperparameters(self) -> None: ...
    def mcmc(self, n: int = ..., burn_in: int = ..., save_every: int = ..., ncores: int = ..., verbose: bool = ...) -> typing.Dict[str, typing.List[typing.Any]]: ...
